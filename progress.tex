\documentclass[12pt]{article}
\usepackage{fullpage,enumitem,amsmath,amssymb,graphicx,hyperref}
\usepackage[margin=1in]{geometry} 

\begin{document}

\begin{center}
{\Large CS221 Fall 2016 Project Progress: Scrabble AI}

\begin{tabular}{rl}
  Authors: & Colleen Josephson $\{$cajoseph$\}$ and Rebecca Greene $\{$greenest$\}$\\
\end{tabular}
\end{center}

\emph{Propose a model and an algorithm for tackling your task. You should
describe the model and algorithm in detail and use a concrete example
to demonstrate how the model and algorithm work. Don't describe
methods in general; describe precisely how they apply to your problem
(what are variables, factors, states, etc.)? You should also have
finished implementing a preliminary version of your algorithm (maybe
it's not fully optimized yet and it doesn't have all the features you
want). Report your initial experimental results.}


\subsubsection*{Introduction}
We are building a Scrabble AI, which is a turn-based board game. In
this progress report we describe our model, our preliminary algorithm,
present preliminary experimental results, and outline additional work
we plan to do before the final deadline.

\subsubsection*{Model}
Scrabble is a challenging game to design models for because the state
space is very large, so traditional models like minimax are not a good
fit. Furthermore, Blah blah.

Based off appel-jacobsen is move generation algo, we will do a
backtracking search on a trie where the letters are edges and nodes
are partial words/words (leaf nodes are words). The maxmum number of
edges from a node is 26. The trie is pre-computed from the dictionary.

The trie itself enforces the constraint of each tile-placement being
the substring of a word in the dictionary. The backtracking search
will enforce the other constraints, namely:
-selected letters must come from the player's tile set
-word must not form a non-word with another part of the board
-word must fit on the board

From there, we will generate all possible moves (or some randomized
subset of them, if this is far too time-consuming) and choose maximal
weight move, where the weight is the standard Scrabble score
function. Some Scrabble AIs have additional heuristics in the score,
such as weighting words based on how they impact the tile rack. We
stuck with the simple scording function for the first pass, but may
conisder additional heuristics for the final result.

With concrete example:

For a concrete example of the backtracking search constraints, please
see the next section.

\subsubsection*{Preliminary Implementation}
The core of the AI is the Appel-Jacobsen algorithm, which does
backtracking search on a trie. At a high level, the backtracking
search builds words around an anchor tile that is already on the
board. The algorithm expands from the anchor left and right using
letters from the player's tile set (or letters already existing on the
board) and then adds tiles left and right until a valid word is
formed. At this point, the word and its score are added to the
list of moves. When the AJ algorithm is complete, the agent choose maximal
scoring move.

Pseudocode of the AJ algorithm:


Toy example (include enforcing constraints):


\subsubsection*{Experiment Setup and Results}
We plan to hook our AI in to the AI that comes with Quackle, an
open-source Scrabble variant whose AI is based off Maven, a
state-of-the-art Scrabble AI from 2006. The Quackle AI has beat human
scrabble champions.

Because the Quackle code is in C++, it is possible to make our AI play
the Quackle AI in an automated manner, but we have not yet had time to
implement that. We plan to do that for the final paper, but in the
meantime we hand-played 5 games of Quackle vs our AI and present the
results below:

(Us vs Quackle)
234, 396


\subsubsection*{Future Work}
-Have our AI auto-play another AI
-do monte-carlo simulation to figure out what your opponent might do
-do DAWG instead of trie if performance is bad?

\end{document}
